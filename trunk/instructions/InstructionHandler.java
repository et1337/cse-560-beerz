package instructions;
import state.MachineState;
import state.MemoryBank;
import java.io.PrintStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
/**
 * Handles a certain type of instruction.
 */
public class InstructionHandler {

	/**
	 * Null output stream. This is used when executing without an output stream, so no
	 * NullPointerExceptions are raised.
	 */
	protected static final PrintStream nullOutStream = new PrintStream(new OutputStream() {
		public void close() {}
		public void flush() {}
		public void write(byte[] b) {}
		public void write(byte[] b, int off, int len) {}
		public void write(int b) {}
	});
	
	/**
	 * Null input stream. This is used when testing, so no
	 * NullPointerExceptions are raised.
	 */
	protected static final InputStream nullInStream = new InputStream() {
		public int read() { return 0; }
	};
	
	/**
	 * Executes the given instruction, manipulating the given MachineState accordingly.
	 * @param output The IO stream to print any output to.
	 * @param input The IO stream to retrieve user input from.
	 * @param instruction The integer value of the instruction to execute, including the four op-code bits.
	 * @param state The MachineState to use and modify when executing.
	 * @param memory The MemoryBank to use and modify when executing.
	 */
	public void execute(PrintStream output, InputStream input, int instruction, MachineState state, MemoryBank memory) {
	}
	
	/**
	 * Convenience method that allows InstructionMappings to execute the instruction with System.in for the input stream.
	 * @param output The IO stream to print any output to.
	 * @param instruction The integer value of the instruction to execute, including the four op-code bits.
	 * @param state The MachineState to use and modify when executing.
	 * @param memory The MemoryBank to use and modify when executing.
	 */
	public void execute(PrintStream output, int instruction, MachineState state, MemoryBank memory) {
		this.execute(output, System.in, instruction, state, memory);
	}
	
	/**
	 * Convenience method that allows tests to execute the instruction without providing an input or output stream.
	 * @param instruction The integer value of the instruction to execute, including the four op-code bits.
	 * @param state The MachineState to use and modify when executing.
	 * @param memory The MemoryBank to use and modify when executing.
	 * @return Any output generated by the InstructionHandler.
	 */
	public String execute(int instruction, MachineState state, MemoryBank memory) {
		OutputStream stream = new ByteArrayOutputStream();
		this.execute(new PrintStream(stream), InstructionHandler.nullInStream, instruction, state, memory);
		return stream.toString();
	}
	
	/**
	 * Convenience method that allows tests to execute the instruction with user input.
	 * Also allows tests to specify user input.
	 * @param input A string containing user input for the instruction. Input lines should be separated with \r\n.
	 * @param instruction The integer value of the instruction to execute, including the four op-code bits.
	 * @param state The MachineState to use and modify when executing.
	 * @param memory The MemoryBank to use and modify when executing.
	 * @return Any output generated by the InstructionHandler.
	 */
	public String execute(String input, int instruction, MachineState state, MemoryBank memory) {
		OutputStream stream = new ByteArrayOutputStream();
		this.execute(InstructionHandler.nullOutStream, new ByteArrayInputStream(input.getBytes()), instruction, state, memory);
		return stream.toString();
	}
	
	/**
	 * Gets the name of the instruction this class handles.
	 * @return The name of the instruction this class handles.
	 */
	public String getName() {
		return "";
	}
}